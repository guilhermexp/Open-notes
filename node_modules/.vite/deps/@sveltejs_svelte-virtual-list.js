import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponent,
  add_iframe_resize_listener,
  add_render_callback,
  append_hydration,
  append_styles,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  create_slot,
  detach,
  element,
  ensure_array_like,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration,
  listen,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  set_custom_element_data,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base
} from "./chunk-ZUFKCA25.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-RDM5KK2T.js";

// node_modules/@sveltejs/svelte-virtual-list/VirtualList.svelte
function add_css(target) {
  append_styles(target, "svelte-1tqh76q", "svelte-virtual-list-viewport.svelte-1tqh76q{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-1tqh76q,svelte-virtual-list-row.svelte-1tqh76q{display:block}svelte-virtual-list-row.svelte-1tqh76q{overflow:hidden}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ item: dirty & /*visible*/
16 });
var get_default_slot_context = (ctx) => ({ item: (
  /*row*/
  ctx[23].data
) });
function fallback_block(ctx) {
  let t;
  return {
    c() {
      t = text("Missing template");
    },
    l(nodes) {
      t = claim_text(nodes, "Missing template");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block(key_1, ctx) {
  let svelte_virtual_list_row;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      svelte_virtual_list_row = element("svelte-virtual-list-row");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l(nodes) {
      svelte_virtual_list_row = claim_element(nodes, "SVELTE-VIRTUAL-LIST-ROW", { class: true });
      var svelte_virtual_list_row_nodes = children(svelte_virtual_list_row);
      if (default_slot_or_fallback) default_slot_or_fallback.l(svelte_virtual_list_row_nodes);
      t = claim_space(svelte_virtual_list_row_nodes);
      svelte_virtual_list_row_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_custom_element_data(svelte_virtual_list_row, "class", "svelte-1tqh76q");
      this.first = svelte_virtual_list_row;
    },
    m(target, anchor) {
      insert_hydration(target, svelte_virtual_list_row, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(svelte_virtual_list_row, null);
      }
      append_hydration(svelte_virtual_list_row, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visible*/
        8208)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_virtual_list_row);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svelte_virtual_list_viewport;
  let svelte_virtual_list_contents;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svelte_virtual_list_viewport_resize_listener;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*visible*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*row*/
    ctx2[23].index
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
      svelte_virtual_list_contents = element("svelte-virtual-list-contents");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      svelte_virtual_list_viewport = claim_element(nodes, "SVELTE-VIRTUAL-LIST-VIEWPORT", { style: true, class: true });
      var svelte_virtual_list_viewport_nodes = children(svelte_virtual_list_viewport);
      svelte_virtual_list_contents = claim_element(svelte_virtual_list_viewport_nodes, "SVELTE-VIRTUAL-LIST-CONTENTS", { style: true, class: true });
      var svelte_virtual_list_contents_nodes = children(svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svelte_virtual_list_contents_nodes);
      }
      svelte_virtual_list_contents_nodes.forEach(detach);
      svelte_virtual_list_viewport_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_style(
        svelte_virtual_list_contents,
        "padding-top",
        /*top*/
        ctx[5] + "px"
      );
      set_style(
        svelte_virtual_list_contents,
        "padding-bottom",
        /*bottom*/
        ctx[6] + "px"
      );
      set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-1tqh76q");
      set_style(
        svelte_virtual_list_viewport,
        "height",
        /*height*/
        ctx[0]
      );
      set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-1tqh76q");
      add_render_callback(() => (
        /*svelte_virtual_list_viewport_elementresize_handler*/
        ctx[17].call(svelte_virtual_list_viewport)
      ));
    },
    m(target, anchor) {
      insert_hydration(target, svelte_virtual_list_viewport, anchor);
      append_hydration(svelte_virtual_list_viewport, svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svelte_virtual_list_contents, null);
        }
      }
      ctx[15](svelte_virtual_list_contents);
      ctx[16](svelte_virtual_list_viewport);
      svelte_virtual_list_viewport_resize_listener = add_iframe_resize_listener(
        svelte_virtual_list_viewport,
        /*svelte_virtual_list_viewport_elementresize_handler*/
        ctx[17].bind(svelte_virtual_list_viewport)
      );
      current = true;
      if (!mounted) {
        dispose = listen(
          svelte_virtual_list_viewport,
          "scroll",
          /*handle_scroll*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$$scope, visible*/
      8208) {
        each_value = ensure_array_like(
          /*visible*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty & /*top*/
      32) {
        set_style(
          svelte_virtual_list_contents,
          "padding-top",
          /*top*/
          ctx2[5] + "px"
        );
      }
      if (!current || dirty & /*bottom*/
      64) {
        set_style(
          svelte_virtual_list_contents,
          "padding-bottom",
          /*bottom*/
          ctx2[6] + "px"
        );
      }
      if (!current || dirty & /*height*/
      1) {
        set_style(
          svelte_virtual_list_viewport,
          "height",
          /*height*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_virtual_list_viewport);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[15](null);
      ctx[16](null);
      svelte_virtual_list_viewport_resize_listener();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { items } = $$props;
  let { height = "100%" } = $$props;
  let { itemHeight = void 0 } = $$props;
  let foo;
  let { start = 0 } = $$props;
  let { end = 0 } = $$props;
  let height_map = [];
  let rows;
  let viewport;
  let contents;
  let viewport_height = 0;
  let visible;
  let mounted;
  let top = 0;
  let bottom = 0;
  let average_height;
  async function refresh(items2, viewport_height2, itemHeight2) {
    const { scrollTop } = viewport;
    await tick();
    let content_height = top - scrollTop;
    let i = start;
    while (content_height < viewport_height2 && i < items2.length) {
      let row = rows[i - start];
      if (!row) {
        $$invalidate(9, end = i + 1);
        await tick();
        row = rows[i - start];
      }
      const row_height = height_map[i] = itemHeight2 || row.offsetHeight;
      content_height += row_height;
      i += 1;
    }
    $$invalidate(9, end = i);
    const remaining = items2.length - end;
    average_height = (top + content_height) / end;
    $$invalidate(6, bottom = remaining * average_height);
    height_map.length = items2.length;
  }
  async function handle_scroll() {
    const { scrollTop } = viewport;
    const old_start = start;
    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = itemHeight || rows[v].offsetHeight;
    }
    let i = 0;
    let y = 0;
    while (i < items.length) {
      const row_height = height_map[i] || average_height;
      if (y + row_height > scrollTop) {
        $$invalidate(8, start = i);
        $$invalidate(5, top = y);
        break;
      }
      y += row_height;
      i += 1;
    }
    while (i < items.length) {
      y += height_map[i] || average_height;
      i += 1;
      if (y > scrollTop + viewport_height) break;
    }
    $$invalidate(9, end = i);
    const remaining = items.length - end;
    average_height = y / end;
    while (i < items.length) height_map[i++] = average_height;
    $$invalidate(6, bottom = remaining * average_height);
    if (start < old_start) {
      await tick();
      let expected_height = 0;
      let actual_height = 0;
      for (let i2 = start; i2 < old_start; i2 += 1) {
        if (rows[i2 - start]) {
          expected_height += height_map[i2];
          actual_height += itemHeight || rows[i2 - start].offsetHeight;
        }
      }
      const d = actual_height - expected_height;
      viewport.scrollTo(0, scrollTop + d);
    }
  }
  onMount(() => {
    rows = contents.getElementsByTagName("svelte-virtual-list-row");
    $$invalidate(12, mounted = true);
  });
  function svelte_virtual_list_contents_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(3, contents);
    });
  }
  function svelte_virtual_list_viewport_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(2, viewport);
    });
  }
  function svelte_virtual_list_viewport_elementresize_handler() {
    viewport_height = this.offsetHeight;
    $$invalidate(1, viewport_height);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2) $$invalidate(10, items = $$props2.items);
    if ("height" in $$props2) $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2) $$invalidate(11, itemHeight = $$props2.itemHeight);
    if ("start" in $$props2) $$invalidate(8, start = $$props2.start);
    if ("end" in $$props2) $$invalidate(9, end = $$props2.end);
    if ("$$scope" in $$props2) $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items, start, end*/
    1792) {
      $: $$invalidate(4, visible = items.slice(start, end).map((data, i) => {
        return { index: i + start, data };
      }));
    }
    if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/
    7170) {
      $: if (mounted) refresh(items, viewport_height, itemHeight);
    }
  };
  return [
    height,
    viewport_height,
    viewport,
    contents,
    visible,
    top,
    bottom,
    handle_scroll,
    start,
    end,
    items,
    itemHeight,
    mounted,
    $$scope,
    slots,
    svelte_virtual_list_contents_binding,
    svelte_virtual_list_viewport_binding,
    svelte_virtual_list_viewport_elementresize_handler
  ];
}
var VirtualList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        items: 10,
        height: 0,
        itemHeight: 11,
        start: 8,
        end: 9
      },
      add_css
    );
  }
};
var VirtualList_default = VirtualList;
export {
  VirtualList_default as default
};
//# sourceMappingURL=@sveltejs_svelte-virtual-list.js.map
