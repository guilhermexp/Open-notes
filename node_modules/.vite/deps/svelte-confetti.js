import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponent,
  append_styles,
  attr,
  children,
  claim_element,
  destroy_each,
  detach,
  element,
  empty,
  ensure_array_like,
  init,
  insert_hydration,
  noop,
  onMount,
  safe_not_equal,
  set_style,
  toggle_class
} from "./chunk-ZUFKCA25.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-RDM5KK2T.js";

// node_modules/svelte-confetti/dist/Confetti.svelte
function add_css(target) {
  append_styles(target, "svelte-io58ff", ".confetti-holder.svelte-io58ff.svelte-io58ff{position:relative}@keyframes svelte-io58ff-rotate{0%{transform:skew(var(--skew)) rotate3d(var(--full-rotation))}100%{transform:skew(var(--skew)) rotate3d(var(--rotation-xyz), calc(var(--rotation-deg) + 360deg))}}@keyframes svelte-io58ff-translate{0%{opacity:1}8%{transform:translateY(calc(var(--translate-y) * 0.95)) translateX(calc(var(--translate-x) * (var(--x-spread) * 0.9)));opacity:1}12%{transform:translateY(var(--translate-y)) translateX(calc(var(--translate-x) * (var(--x-spread) * 0.95)));opacity:1}16%{transform:translateY(var(--translate-y)) translateX(calc(var(--translate-x) * var(--x-spread)));opacity:1}100%{transform:translateY(calc(var(--translate-y) + var(--fall-distance))) translateX(var(--translate-x));opacity:0}}@keyframes svelte-io58ff-no-gravity-translate{0%{opacity:1}100%{transform:translateY(var(--translate-y)) translateX(var(--translate-x));opacity:0}}.confetti.svelte-io58ff.svelte-io58ff{--translate-y:calc(-200px * var(--translate-y-multiplier));--translate-x:calc(200px * var(--translate-x-multiplier));position:absolute;height:calc(var(--size) * var(--scale));width:calc(var(--size) * var(--scale));animation:svelte-io58ff-translate var(--transition-duration) var(--transition-delay) var(--transition-iteration-count) linear;opacity:0;pointer-events:none}.confetti.svelte-io58ff.svelte-io58ff::before{--full-rotation:var(--rotation-xyz), var(--rotation-deg);content:'';display:block;width:100%;height:100%;background:var(--color);background-size:contain;transform:skew(var(--skew)) rotate3d(var(--full-rotation));animation:svelte-io58ff-rotate var(--transition-duration) var(--transition-delay) var(--transition-iteration-count) linear}.rounded.svelte-io58ff .confetti.svelte-io58ff::before{border-radius:50%}.cone.svelte-io58ff .confetti.svelte-io58ff{--translate-x:calc(200px * var(--translate-y-multiplier) * var(--translate-x-multiplier))}.no-gravity.svelte-io58ff .confetti.svelte-io58ff{animation-name:svelte-io58ff-no-gravity-translate;animation-timing-function:ease-out}@media(prefers-reduced-motion){.confetti.svelte-io58ff.svelte-io58ff,.confetti.svelte-io58ff.svelte-io58ff::before{animation:none}}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let each_value = ensure_array_like({ length: (
    /*amount*/
    ctx[6]
  ) });
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "confetti-holder svelte-io58ff");
      toggle_class(
        div,
        "rounded",
        /*rounded*/
        ctx[9]
      );
      toggle_class(
        div,
        "cone",
        /*cone*/
        ctx[10]
      );
      toggle_class(
        div,
        "no-gravity",
        /*noGravity*/
        ctx[11]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*fallDistance, size, getColor, randomBetween, y, x, infinite, duration, delay, iterationCount, xSpread, amount*/
      20991) {
        each_value = ensure_array_like({ length: (
          /*amount*/
          ctx2[6]
        ) });
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*rounded*/
      512) {
        toggle_class(
          div,
          "rounded",
          /*rounded*/
          ctx2[9]
        );
      }
      if (dirty & /*cone*/
      1024) {
        toggle_class(
          div,
          "cone",
          /*cone*/
          ctx2[10]
        );
      }
      if (dirty & /*noGravity*/
      2048) {
        toggle_class(
          div,
          "no-gravity",
          /*noGravity*/
          ctx2[11]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "confetti svelte-io58ff");
      set_style(
        div,
        "--fall-distance",
        /*fallDistance*/
        ctx[8]
      );
      set_style(
        div,
        "--size",
        /*size*/
        ctx[0] + "px"
      );
      set_style(
        div,
        "--color",
        /*getColor*/
        ctx[14]()
      );
      set_style(div, "--skew", randomBetween(-45, 45) + "deg," + randomBetween(-45, 45) + "deg");
      set_style(div, "--rotation-xyz", randomBetween(-10, 10) + ", " + randomBetween(-10, 10) + ", " + randomBetween(-10, 10));
      set_style(div, "--rotation-deg", randomBetween(0, 360) + "deg");
      set_style(div, "--translate-y-multiplier", randomBetween(
        /*y*/
        ctx[2][0],
        /*y*/
        ctx[2][1]
      ));
      set_style(div, "--translate-x-multiplier", randomBetween(
        /*x*/
        ctx[1][0],
        /*x*/
        ctx[1][1]
      ));
      set_style(div, "--scale", 0.1 * randomBetween(2, 10));
      set_style(
        div,
        "--transition-duration",
        /*infinite*/
        ctx[4] ? `calc(${/*duration*/
        ctx[3]}ms * var(--scale))` : `${/*duration*/
        ctx[3]}ms`
      );
      set_style(div, "--transition-delay", randomBetween(
        /*delay*/
        ctx[5][0],
        /*delay*/
        ctx[5][1]
      ) + "ms");
      set_style(
        div,
        "--transition-iteration-count",
        /*infinite*/
        ctx[4] ? "infinite" : (
          /*iterationCount*/
          ctx[7]
        )
      );
      set_style(div, "--x-spread", 1 - /*xSpread*/
      ctx[12]);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*fallDistance*/
      256) {
        set_style(
          div,
          "--fall-distance",
          /*fallDistance*/
          ctx2[8]
        );
      }
      if (dirty & /*size*/
      1) {
        set_style(
          div,
          "--size",
          /*size*/
          ctx2[0] + "px"
        );
      }
      if (dirty & /*y*/
      4) {
        set_style(div, "--translate-y-multiplier", randomBetween(
          /*y*/
          ctx2[2][0],
          /*y*/
          ctx2[2][1]
        ));
      }
      if (dirty & /*x*/
      2) {
        set_style(div, "--translate-x-multiplier", randomBetween(
          /*x*/
          ctx2[1][0],
          /*x*/
          ctx2[1][1]
        ));
      }
      if (dirty & /*infinite, duration*/
      24) {
        set_style(
          div,
          "--transition-duration",
          /*infinite*/
          ctx2[4] ? `calc(${/*duration*/
          ctx2[3]}ms * var(--scale))` : `${/*duration*/
          ctx2[3]}ms`
        );
      }
      if (dirty & /*delay*/
      32) {
        set_style(div, "--transition-delay", randomBetween(
          /*delay*/
          ctx2[5][0],
          /*delay*/
          ctx2[5][1]
        ) + "ms");
      }
      if (dirty & /*infinite, iterationCount*/
      144) {
        set_style(
          div,
          "--transition-iteration-count",
          /*infinite*/
          ctx2[4] ? "infinite" : (
            /*iterationCount*/
            ctx2[7]
          )
        );
      }
      if (dirty & /*xSpread*/
      4096) {
        set_style(div, "--x-spread", 1 - /*xSpread*/
        ctx2[12]);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = !/*complete*/
  ctx[13] && create_if_block(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (!/*complete*/
      ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function randomBetween(min, max) {
  return Math.random() * (max - min) + min;
}
function instance($$self, $$props, $$invalidate) {
  let { size = 10 } = $$props;
  let { x = [-0.5, 0.5] } = $$props;
  let { y = [0.25, 1] } = $$props;
  let { duration = 2e3 } = $$props;
  let { infinite = false } = $$props;
  let { delay = [0, 50] } = $$props;
  let { colorRange = [0, 360] } = $$props;
  let { colorArray = [] } = $$props;
  let { amount = 50 } = $$props;
  let { iterationCount = 1 } = $$props;
  let { fallDistance = "100px" } = $$props;
  let { rounded = false } = $$props;
  let { cone = false } = $$props;
  let { noGravity = false } = $$props;
  let { xSpread = 0.15 } = $$props;
  let { destroyOnComplete = true } = $$props;
  let complete = false;
  onMount(() => {
    if (!destroyOnComplete || infinite || iterationCount == "infinite") return;
    setTimeout(() => $$invalidate(13, complete = true), (duration + delay[1]) * iterationCount);
  });
  function getColor() {
    if (colorArray.length) return colorArray[Math.round(Math.random() * (colorArray.length - 1))];
    else return `hsl(${Math.round(randomBetween(colorRange[0], colorRange[1]))}, 75%, 50%)`;
  }
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2) $$invalidate(0, size = $$props2.size);
    if ("x" in $$props2) $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(2, y = $$props2.y);
    if ("duration" in $$props2) $$invalidate(3, duration = $$props2.duration);
    if ("infinite" in $$props2) $$invalidate(4, infinite = $$props2.infinite);
    if ("delay" in $$props2) $$invalidate(5, delay = $$props2.delay);
    if ("colorRange" in $$props2) $$invalidate(15, colorRange = $$props2.colorRange);
    if ("colorArray" in $$props2) $$invalidate(16, colorArray = $$props2.colorArray);
    if ("amount" in $$props2) $$invalidate(6, amount = $$props2.amount);
    if ("iterationCount" in $$props2) $$invalidate(7, iterationCount = $$props2.iterationCount);
    if ("fallDistance" in $$props2) $$invalidate(8, fallDistance = $$props2.fallDistance);
    if ("rounded" in $$props2) $$invalidate(9, rounded = $$props2.rounded);
    if ("cone" in $$props2) $$invalidate(10, cone = $$props2.cone);
    if ("noGravity" in $$props2) $$invalidate(11, noGravity = $$props2.noGravity);
    if ("xSpread" in $$props2) $$invalidate(12, xSpread = $$props2.xSpread);
    if ("destroyOnComplete" in $$props2) $$invalidate(17, destroyOnComplete = $$props2.destroyOnComplete);
  };
  return [
    size,
    x,
    y,
    duration,
    infinite,
    delay,
    amount,
    iterationCount,
    fallDistance,
    rounded,
    cone,
    noGravity,
    xSpread,
    complete,
    getColor,
    colorRange,
    colorArray,
    destroyOnComplete
  ];
}
var Confetti = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        size: 0,
        x: 1,
        y: 2,
        duration: 3,
        infinite: 4,
        delay: 5,
        colorRange: 15,
        colorArray: 16,
        amount: 6,
        iterationCount: 7,
        fallDistance: 8,
        rounded: 9,
        cone: 10,
        noGravity: 11,
        xSpread: 12,
        destroyOnComplete: 17
      },
      add_css
    );
  }
};
var Confetti_default = Confetti;

// node_modules/svelte-confetti/dist/index.js
var dist_default = Confetti_default;
export {
  Confetti_default as Confetti,
  dist_default as default
};
//# sourceMappingURL=svelte-confetti.js.map
