"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DragHandle: () => DragHandle,
  DragHandlePlugin: () => DragHandlePlugin,
  default: () => index_default,
  defaultComputePositionConfig: () => defaultComputePositionConfig,
  dragHandlePluginDefaultKey: () => dragHandlePluginDefaultKey
});
module.exports = __toCommonJS(index_exports);

// src/drag-handle.ts
var import_core = require("@tiptap/core");

// src/drag-handle-plugin.ts
var import_dom = require("@floating-ui/dom");
var import_extension_collaboration = require("@tiptap/extension-collaboration");
var import_state = require("@tiptap/pm/state");
var import_y_tiptap = require("@tiptap/y-tiptap");

// src/helpers/dragHandler.ts
var import_extension_node_range = require("@tiptap/extension-node-range");

// src/helpers/cloneElement.ts
function getCSSText(element) {
  let value = "";
  const style = getComputedStyle(element);
  for (let i = 0; i < style.length; i += 1) {
    value += `${style[i]}:${style.getPropertyValue(style[i])};`;
  }
  return value;
}
function cloneElement(node) {
  const clonedNode = node.cloneNode(true);
  const sourceElements = [node, ...Array.from(node.getElementsByTagName("*"))];
  const targetElements = [clonedNode, ...Array.from(clonedNode.getElementsByTagName("*"))];
  sourceElements.forEach((sourceElement, index) => {
    targetElements[index].style.cssText = getCSSText(sourceElement);
  });
  return clonedNode;
}

// src/helpers/findNextElementFromCursor.ts
var findElementNextToCoords = (options) => {
  const { x, y, direction, editor } = options;
  let resultElement = null;
  let resultNode = null;
  let pos = null;
  let currentX = x;
  while (resultNode === null && currentX < window.innerWidth && currentX > 0) {
    const allElements = document.elementsFromPoint(currentX, y);
    const prosemirrorIndex = allElements.findIndex((element) => element.classList.contains("ProseMirror"));
    const filteredElements = allElements.slice(0, prosemirrorIndex);
    if (filteredElements.length > 0) {
      const target = filteredElements[0];
      resultElement = target;
      pos = editor.view.posAtDOM(target, 0);
      if (pos >= 0) {
        resultNode = editor.state.doc.nodeAt(Math.max(pos - 1, 0));
        if (resultNode == null ? void 0 : resultNode.isText) {
          resultNode = editor.state.doc.nodeAt(Math.max(pos - 1, 0));
        }
        if (!resultNode) {
          resultNode = editor.state.doc.nodeAt(Math.max(pos, 0));
        }
        break;
      }
    }
    if (direction === "left") {
      currentX -= 1;
    } else {
      currentX += 1;
    }
  }
  return { resultElement, resultNode, pos: pos != null ? pos : null };
};

// src/helpers/getComputedStyle.ts
function getComputedStyle2(node, property) {
  const style = window.getComputedStyle(node);
  return style[property];
}

// src/helpers/minMax.ts
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}

// src/helpers/getInnerCoords.ts
function getInnerCoords(view, x, y) {
  const paddingLeft = parseInt(getComputedStyle2(view.dom, "paddingLeft"), 10);
  const paddingRight = parseInt(getComputedStyle2(view.dom, "paddingRight"), 10);
  const borderLeft = parseInt(getComputedStyle2(view.dom, "borderLeftWidth"), 10);
  const borderRight = parseInt(getComputedStyle2(view.dom, "borderLeftWidth"), 10);
  const bounds = view.dom.getBoundingClientRect();
  const coords = {
    left: minMax(x, bounds.left + paddingLeft + borderLeft, bounds.right - paddingRight - borderRight),
    top: y
  };
  return coords;
}

// src/helpers/removeNode.ts
function removeNode(node) {
  var _a;
  (_a = node.parentNode) == null ? void 0 : _a.removeChild(node);
}

// src/helpers/dragHandler.ts
function getDragHandleRanges(event, editor) {
  const { doc } = editor.view.state;
  const result = findElementNextToCoords({
    editor,
    x: event.clientX,
    y: event.clientY,
    direction: "right"
  });
  if (!result.resultNode || result.pos === null) {
    return [];
  }
  const x = event.clientX;
  const coords = getInnerCoords(editor.view, x, event.clientY);
  const posAtCoords = editor.view.posAtCoords(coords);
  if (!posAtCoords) {
    return [];
  }
  const { pos } = posAtCoords;
  const nodeAt = doc.resolve(pos).parent;
  if (!nodeAt) {
    return [];
  }
  const $from = doc.resolve(result.pos);
  const $to = doc.resolve(result.pos + 1);
  return (0, import_extension_node_range.getSelectionRanges)($from, $to, 0);
}
function dragHandler(event, editor) {
  const { view } = editor;
  if (!event.dataTransfer) {
    return;
  }
  const { empty, $from, $to } = view.state.selection;
  const dragHandleRanges = getDragHandleRanges(event, editor);
  const selectionRanges = (0, import_extension_node_range.getSelectionRanges)($from, $to, 0);
  const isDragHandleWithinSelection = selectionRanges.some((range) => {
    return dragHandleRanges.find((dragHandleRange) => {
      return dragHandleRange.$from === range.$from && dragHandleRange.$to === range.$to;
    });
  });
  const ranges = empty || !isDragHandleWithinSelection ? dragHandleRanges : selectionRanges;
  if (!ranges.length) {
    return;
  }
  const { tr } = view.state;
  const wrapper = document.createElement("div");
  const from = ranges[0].$from.pos;
  const to = ranges[ranges.length - 1].$to.pos;
  const selection = import_extension_node_range.NodeRangeSelection.create(view.state.doc, from, to);
  const slice = selection.content();
  ranges.forEach((range) => {
    const element = view.nodeDOM(range.$from.pos);
    const clonedElement = cloneElement(element);
    wrapper.append(clonedElement);
  });
  wrapper.style.position = "absolute";
  wrapper.style.top = "-10000px";
  document.body.append(wrapper);
  event.dataTransfer.clearData();
  event.dataTransfer.setDragImage(wrapper, 0, 0);
  view.dragging = { slice, move: true };
  tr.setSelection(selection);
  view.dispatch(tr);
  document.addEventListener("drop", () => removeNode(wrapper), { once: true });
}

// src/helpers/getOuterNode.ts
var getOuterNodePos = (doc, pos) => {
  const resolvedPos = doc.resolve(pos);
  const { depth } = resolvedPos;
  if (depth === 0) {
    return pos;
  }
  const a = resolvedPos.pos - resolvedPos.parentOffset;
  return a - 1;
};
var getOuterNode = (doc, pos) => {
  const node = doc.nodeAt(pos);
  const resolvedPos = doc.resolve(pos);
  let { depth } = resolvedPos;
  let parent = node;
  while (depth > 0) {
    const currentNode = resolvedPos.node(depth);
    depth -= 1;
    if (depth === 0) {
      parent = currentNode;
    }
  }
  return parent;
};

// src/drag-handle-plugin.ts
var getRelativePos = (state, absolutePos) => {
  const ystate = import_y_tiptap.ySyncPluginKey.getState(state);
  if (!ystate) {
    return null;
  }
  return (0, import_y_tiptap.absolutePositionToRelativePosition)(absolutePos, ystate.type, ystate.binding.mapping);
};
var getAbsolutePos = (state, relativePos) => {
  const ystate = import_y_tiptap.ySyncPluginKey.getState(state);
  if (!ystate) {
    return -1;
  }
  return (0, import_y_tiptap.relativePositionToAbsolutePosition)(ystate.doc, ystate.type, relativePos, ystate.binding.mapping) || 0;
};
var getOuterDomNode = (view, domNode) => {
  let tmpDomNode = domNode;
  while (tmpDomNode == null ? void 0 : tmpDomNode.parentNode) {
    if (tmpDomNode.parentNode === view.dom) {
      break;
    }
    tmpDomNode = tmpDomNode.parentNode;
  }
  return tmpDomNode;
};
var dragHandlePluginDefaultKey = new import_state.PluginKey("dragHandle");
var DragHandlePlugin = ({
  pluginKey = dragHandlePluginDefaultKey,
  element,
  editor,
  computePositionConfig,
  onNodeChange
}) => {
  const wrapper = document.createElement("div");
  let locked = false;
  let currentNode = null;
  let currentNodePos = -1;
  let currentNodeRelPos;
  function hideHandle() {
    if (!element) {
      return;
    }
    element.style.visibility = "hidden";
    element.style.pointerEvents = "none";
  }
  function showHandle() {
    if (!element) {
      return;
    }
    if (!editor.isEditable) {
      hideHandle();
      return;
    }
    element.style.visibility = "";
    element.style.pointerEvents = "auto";
  }
  function repositionDragHandle(dom) {
    const virtualElement = {
      getBoundingClientRect: () => dom.getBoundingClientRect()
    };
    (0, import_dom.computePosition)(virtualElement, element, computePositionConfig).then((val) => {
      Object.assign(element.style, {
        position: val.strategy,
        left: `${val.x}px`,
        top: `${val.y}px`
      });
    });
  }
  function onDragStart(e) {
    dragHandler(e, editor);
    setTimeout(() => {
      if (element) {
        element.style.pointerEvents = "none";
      }
    }, 0);
  }
  function onDragEnd() {
    hideHandle();
    if (element) {
      element.style.pointerEvents = "auto";
    }
  }
  element.addEventListener("dragstart", onDragStart);
  element.addEventListener("dragend", onDragEnd);
  wrapper.appendChild(element);
  return {
    unbind() {
      element.removeEventListener("dragstart", onDragStart);
      element.removeEventListener("dragend", onDragEnd);
    },
    plugin: new import_state.Plugin({
      key: typeof pluginKey === "string" ? new import_state.PluginKey(pluginKey) : pluginKey,
      state: {
        init() {
          return { locked: false };
        },
        apply(tr, value, _oldState, state) {
          const isLocked = tr.getMeta("lockDragHandle");
          const hideDragHandle = tr.getMeta("hideDragHandle");
          if (isLocked !== void 0) {
            locked = isLocked;
          }
          if (hideDragHandle) {
            hideHandle();
            locked = false;
            currentNode = null;
            currentNodePos = -1;
            onNodeChange == null ? void 0 : onNodeChange({ editor, node: null, pos: -1 });
            return value;
          }
          if (tr.docChanged && currentNodePos !== -1 && element) {
            if ((0, import_extension_collaboration.isChangeOrigin)(tr)) {
              const newPos = getAbsolutePos(state, currentNodeRelPos);
              if (newPos !== currentNodePos) {
                currentNodePos = newPos;
              }
            } else {
              const newPos = tr.mapping.map(currentNodePos);
              if (newPos !== currentNodePos) {
                currentNodePos = newPos;
                currentNodeRelPos = getRelativePos(state, currentNodePos);
              }
            }
          }
          return value;
        }
      },
      view: (view) => {
        var _a;
        element.draggable = true;
        element.style.pointerEvents = "auto";
        (_a = editor.view.dom.parentElement) == null ? void 0 : _a.appendChild(wrapper);
        wrapper.style.pointerEvents = "none";
        wrapper.style.position = "absolute";
        wrapper.style.top = "0";
        wrapper.style.left = "0";
        return {
          update(_, oldState) {
            if (!element) {
              return;
            }
            if (!editor.isEditable) {
              hideHandle();
              return;
            }
            if (locked) {
              element.draggable = false;
            } else {
              element.draggable = true;
            }
            if (view.state.doc.eq(oldState.doc) || currentNodePos === -1) {
              return;
            }
            let domNode = view.nodeDOM(currentNodePos);
            domNode = getOuterDomNode(view, domNode);
            if (domNode === view.dom) {
              return;
            }
            if ((domNode == null ? void 0 : domNode.nodeType) !== 1) {
              return;
            }
            const domNodePos = view.posAtDOM(domNode, 0);
            const outerNode = getOuterNode(editor.state.doc, domNodePos);
            const outerNodePos = getOuterNodePos(editor.state.doc, domNodePos);
            currentNode = outerNode;
            currentNodePos = outerNodePos;
            currentNodeRelPos = getRelativePos(view.state, currentNodePos);
            onNodeChange == null ? void 0 : onNodeChange({ editor, node: currentNode, pos: currentNodePos });
            repositionDragHandle(domNode);
          },
          // TODO: Kills even on hot reload
          destroy() {
            if (element) {
              removeNode(wrapper);
            }
          }
        };
      },
      props: {
        handleDOMEvents: {
          keydown(view) {
            if (!element || locked) {
              return false;
            }
            if (view.hasFocus()) {
              hideHandle();
              currentNode = null;
              currentNodePos = -1;
              onNodeChange == null ? void 0 : onNodeChange({ editor, node: null, pos: -1 });
              return false;
            }
            return false;
          },
          mouseleave(_view, e) {
            if (locked) {
              return false;
            }
            if (e.target && !wrapper.contains(e.relatedTarget)) {
              hideHandle();
              currentNode = null;
              currentNodePos = -1;
              onNodeChange == null ? void 0 : onNodeChange({ editor, node: null, pos: -1 });
            }
            return false;
          },
          mousemove(view, e) {
            if (!element || locked) {
              return false;
            }
            const nodeData = findElementNextToCoords({
              x: e.clientX,
              y: e.clientY,
              direction: "right",
              editor
            });
            if (!nodeData.resultElement) {
              return false;
            }
            let domNode = nodeData.resultElement;
            domNode = getOuterDomNode(view, domNode);
            if (domNode === view.dom) {
              return false;
            }
            if ((domNode == null ? void 0 : domNode.nodeType) !== 1) {
              return false;
            }
            const domNodePos = view.posAtDOM(domNode, 0);
            const outerNode = getOuterNode(editor.state.doc, domNodePos);
            if (outerNode !== currentNode) {
              const outerNodePos = getOuterNodePos(editor.state.doc, domNodePos);
              currentNode = outerNode;
              currentNodePos = outerNodePos;
              currentNodeRelPos = getRelativePos(view.state, currentNodePos);
              onNodeChange == null ? void 0 : onNodeChange({ editor, node: currentNode, pos: currentNodePos });
              repositionDragHandle(domNode);
              showHandle();
            }
            return false;
          }
        }
      }
    })
  };
};

// src/drag-handle.ts
var defaultComputePositionConfig = {
  placement: "left-start",
  strategy: "absolute"
};
var DragHandle = import_core.Extension.create({
  name: "dragHandle",
  addOptions() {
    return {
      render() {
        const element = document.createElement("div");
        element.classList.add("drag-handle");
        return element;
      },
      computePositionConfig: {},
      locked: false,
      onNodeChange: () => {
        return null;
      }
    };
  },
  addCommands() {
    return {
      lockDragHandle: () => ({ editor }) => {
        this.options.locked = true;
        return editor.commands.setMeta("lockDragHandle", this.options.locked);
      },
      unlockDragHandle: () => ({ editor }) => {
        this.options.locked = false;
        return editor.commands.setMeta("lockDragHandle", this.options.locked);
      },
      toggleDragHandle: () => ({ editor }) => {
        this.options.locked = !this.options.locked;
        return editor.commands.setMeta("lockDragHandle", this.options.locked);
      }
    };
  },
  addProseMirrorPlugins() {
    const element = this.options.render();
    return [
      DragHandlePlugin({
        computePositionConfig: { ...defaultComputePositionConfig, ...this.options.computePositionConfig },
        element,
        editor: this.editor,
        onNodeChange: this.options.onNodeChange
      }).plugin
    ];
  }
});

// src/index.ts
var index_default = DragHandle;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DragHandle,
  DragHandlePlugin,
  defaultComputePositionConfig,
  dragHandlePluginDefaultKey
});
//# sourceMappingURL=index.cjs.map